# Dev Instructions: Story 9.1 Security Fixes

## Overview

Critical security vulnerabilities were identified in Story 9.1 (User Creation & Management) during QA review. These must be fixed before production deployment.

**Quality Gate Status**: FAIL (Risk Score: 40/100)
**Priority**: CRITICAL - Security vulnerabilities

---

## Fix 1: Implement NextAuth.js Admin Role Authentication

**Issue**: Authentication middleware bypassed - `requireAdminRole` function returns null, allowing unauthorized access to all admin endpoints.

**Files to Fix**:
- `packages/frontend/src/app/api/v1/admin/users/route.ts:25-29`
- `packages/frontend/src/app/api/v1/admin/users/[id]/route.ts`
- `packages/frontend/src/app/api/v1/admin/users/[id]/status/route.ts`
- `packages/frontend/src/app/api/v1/admin/users/bulk-import/route.ts`

### Implementation Steps

#### 1. Create Auth Configuration (if not exists)
```typescript
// lib/auth.ts or auth.config.ts
import NextAuth from "next-auth"
import { NextAuthConfig } from "next-auth"

export const authConfig: NextAuthConfig = {
  providers: [
    // Your existing providers
  ],
  callbacks: {
    jwt({ token, user }) {
      if (user) {
        token.role = user.role
        token.id = user.id
        token.name = user.name
      }
      return token
    },
    session({ session, token }) {
      if (session.user) {
        session.user.role = token.role
        session.user.id = token.id as string
      }
      return session
    },
  },
  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
  }
}

export const { handlers, auth, signIn, signOut } = NextAuth(authConfig)
```

#### 2. Replace requireAdminRole Function

**REPLACE THIS**:
```typescript
// Middleware function to check admin access
async function requireAdminRole(request: NextRequest) {
  // TODO: Implement proper admin role checking with NextAuth
  // For now, return null (allow access)
  return null;
}
```

**WITH THIS**:
```typescript
import { getToken } from "next-auth/jwt"
import { NextRequest, NextResponse } from "next/server"

// Middleware function to check admin access
async function requireAdminRole(request: NextRequest) {
  try {
    const token = await getToken({ 
      req: request,
      secret: process.env.NEXTAUTH_SECRET 
    })
    
    if (!token) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Authentication required', 
          message: 'Please sign in to access this resource',
          timestamp: new Date().toISOString()
        }, 
        { status: 401 }
      )
    }
    
    if (token.role !== 'ADMIN') {
      return NextResponse.json(
        { 
          success: false,
          error: 'Insufficient permissions', 
          message: 'Admin role required to access this resource',
          timestamp: new Date().toISOString()
        }, 
        { status: 403 }
      )
    }
    
    // Return null to allow access (attach user info to request if needed)
    return null
  } catch (error) {
    console.error('Auth middleware error:', error)
    return NextResponse.json(
      { 
        success: false,
        error: 'Authentication error', 
        message: 'Unable to verify authentication',
        timestamp: new Date().toISOString()
      }, 
      { status: 500 }
    )
  }
}

// Helper to get current user from token
async function getCurrentUser(request: NextRequest) {
  const token = await getToken({ 
    req: request,
    secret: process.env.NEXTAUTH_SECRET 
  })
  
  return token ? {
    id: token.id as string,
    name: token.name as string,
    email: token.email as string,
    role: token.role as string
  } : null
}
```

#### 3. Update User Creation to Use Real Admin Info

**REPLACE THIS**:
```typescript
// TODO: Get current user info from session for audit trail
const currentUserId = 'temp-admin-id'; // Replace with actual session user ID
const currentUserName = 'Temp Admin'; // Replace with actual session user name
```

**WITH THIS**:
```typescript
// Get current user info from session for audit trail
const currentUser = await getCurrentUser(request)
if (!currentUser) {
  return NextResponse.json({
    success: false,
    error: 'Authentication required',
    message: 'Unable to identify current user',
    timestamp: new Date().toISOString(),
  }, { status: 401 });
}

const currentUserId = currentUser.id
const currentUserName = currentUser.name
```

---

## Fix 2: Implement Secure Password Generation System

**Issue**: No password generation or secure delivery system implemented for new user accounts.

**Files to Create/Modify**:
- `packages/frontend/src/lib/services/PasswordService.ts` (new)
- `packages/frontend/src/lib/services/EmailService.ts` (new)
- `packages/frontend/src/app/api/v1/admin/users/route.ts` (modify POST method)

### Implementation Steps

#### 1. Create Password Generation Service
```typescript
// packages/frontend/src/lib/services/PasswordService.ts
import { randomBytes, createHash } from 'crypto'

export class PasswordService {
  /**
   * Generate cryptographically secure password
   */
  static generateSecurePassword(length: number = 12): string {
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*'
    const bytes = randomBytes(length)
    let password = ''
    
    for (let i = 0; i < length; i++) {
      password += charset[bytes[i] % charset.length]
    }
    
    return password
  }

  /**
   * Generate reset token for password links
   */
  static generateResetToken(): string {
    return randomBytes(32).toString('hex')
  }

  /**
   * Hash password for secure storage (if needed)
   */
  static hashPassword(password: string): string {
    return createHash('sha256').update(password).digest('hex')
  }

  /**
   * Generate temporary password with expiry
   */
  static generateTemporaryCredentials() {
    return {
      password: this.generateSecurePassword(12),
      resetToken: this.generateResetToken(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
    }
  }
}
```

#### 2. Create Email Service
```typescript
// packages/frontend/src/lib/services/EmailService.ts
import nodemailer from 'nodemailer'

interface WelcomeEmailData {
  name: string
  email: string
  temporaryPassword: string
  resetToken: string
  organizationName?: string
}

export class EmailService {
  private static transporter = nodemailer.createTransporter({
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT || '587'),
    secure: process.env.SMTP_SECURE === 'true',
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASSWORD,
    },
    tls: {
      rejectUnauthorized: false
    }
  })

  /**
   * Send welcome email with temporary credentials
   */
  static async sendWelcomeEmail(userData: WelcomeEmailData): Promise<void> {
    const resetUrl = `${process.env.NEXTAUTH_URL}/auth/reset-password?token=${userData.resetToken}`
    
    const mailOptions = {
      from: {
        name: 'DMS Admin',
        address: process.env.SMTP_FROM_EMAIL || process.env.SMTP_USER
      },
      to: userData.email,
      subject: 'Welcome to DMS - Account Created',
      html: `
        <div style="max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif;">
          <h2>Welcome to the Disaster Management System</h2>
          
          <p>Hello ${userData.name},</p>
          
          <p>Your account has been created successfully. Here are your login credentials:</p>
          
          <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
            <p><strong>Email:</strong> ${userData.email}</p>
            <p><strong>Temporary Password:</strong> <code>${userData.temporaryPassword}</code></p>
          </div>
          
          <p><strong>⚠️ Important Security Notice:</strong></p>
          <ul>
            <li>This temporary password expires in 24 hours</li>
            <li>You must change your password on first login</li>
            <li>Keep these credentials secure</li>
          </ul>
          
          <p>
            <a href="${resetUrl}" style="background: #0066cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 20px 0;">
              Set Permanent Password
            </a>
          </p>
          
          <p>If the button doesn't work, copy and paste this link into your browser:</p>
          <p><a href="${resetUrl}">${resetUrl}</a></p>
          
          <hr style="margin: 30px 0;">
          <p style="color: #666; font-size: 12px;">
            If you did not expect this email, please contact your system administrator immediately.
          </p>
        </div>
      `
    }

    try {
      await this.transporter.sendMail(mailOptions)
      console.log(`Welcome email sent successfully to ${userData.email}`)
    } catch (error) {
      console.error('Failed to send welcome email:', error)
      throw new Error('Failed to send welcome email')
    }
  }

  /**
   * Test email configuration
   */
  static async testConnection(): Promise<boolean> {
    try {
      await this.transporter.verify()
      return true
    } catch (error) {
      console.error('SMTP connection test failed:', error)
      return false
    }
  }
}
```

#### 3. Update User Creation API

Add to POST method in `packages/frontend/src/app/api/v1/admin/users/route.ts`:

```typescript
import { PasswordService } from '@/lib/services/PasswordService'
import { EmailService } from '@/lib/services/EmailService'

// After successful user creation, before return statement:
try {
  // Generate temporary credentials
  const credentials = PasswordService.generateTemporaryCredentials()
  
  // Store reset token in database (you may need to add this field to User model)
  await DatabaseService.updateUser(newUser.id, {
    resetToken: credentials.resetToken,
    resetTokenExpiry: credentials.expiresAt,
    requirePasswordReset: true
  })
  
  // Send welcome email
  await EmailService.sendWelcomeEmail({
    name: userData.name,
    email: userData.email,
    temporaryPassword: credentials.password,
    resetToken: credentials.resetToken,
    organizationName: userData.organization
  })
  
  console.log(`User created successfully: ${userData.email}`)
  
} catch (emailError) {
  console.error('Failed to send welcome email:', emailError)
  // Don't fail the user creation, but log the error
  // Consider adding a flag to retry email sending later
}
```

#### 4. Environment Variables Required

Add to `.env.local`:
```bash
# SMTP Configuration
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
SMTP_FROM_EMAIL=noreply@yourdomain.com

# NextAuth
NEXTAUTH_SECRET=your-secret-key-here
NEXTAUTH_URL=http://localhost:3000
```

---

## Fix 3: Resolve Jest/Prisma Test Configuration Issues

**Issue**: Tests failing with "PrismaClient is unable to run in this browser environment" error.

### Implementation Steps

#### 1. Install Required Dependencies
```bash
pnpm add -D @quramy/jest-prisma jest-environment-node
```

#### 2. Update Jest Configuration

**Create/Update** `jest.config.mjs`:
```javascript
export default {
  preset: 'ts-jest',
  testEnvironment: '@quramy/jest-prisma/environment',
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  testMatch: [
    '**/__tests__/**/*.(test|spec).(ts|tsx|js|jsx)',
    '**/*.(test|spec).(ts|tsx|js|jsx)'
  ],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@shared/(.*)$': '<rootDir>/../shared/$1'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{ts,tsx}',
    '!src/__tests__/**/*'
  ],
  testPathIgnorePatterns: [
    '<rootDir>/.next/',
    '<rootDir>/node_modules/'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: 'tsconfig.json'
    }]
  }
}
```

#### 3. Create Test Setup File

**Create** `src/__tests__/setup.ts`:
```typescript
import { beforeAll, beforeEach, afterAll } from '@jest/globals'

// Mock next/navigation for tests
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(() => ({
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
    forward: jest.fn(),
    refresh: jest.fn(),
    prefetch: jest.fn(),
  })),
  useSearchParams: jest.fn(() => new URLSearchParams()),
  usePathname: jest.fn(() => '/'),
}))

// Mock NextAuth
jest.mock('next-auth/jwt', () => ({
  getToken: jest.fn(),
}))

beforeAll(async () => {
  // Global test setup
})

beforeEach(() => {
  // Reset mocks between tests
  jest.clearAllMocks()
})

afterAll(async () => {
  // Global test cleanup
})
```

#### 4. Update Test Environment Variables

**Create** `.env.test`:
```bash
DATABASE_URL="postgresql://test:test@localhost:5433/dms_test"
NEXTAUTH_SECRET="test-secret"
NEXTAUTH_URL="http://localhost:3000"
```

#### 5. Fix API Route Tests

**Update test files** to mock authentication properly:

```typescript
// Example: src/__tests__/app/api/v1/admin/users/route.test.ts
import { getToken } from 'next-auth/jwt'
import { POST, GET } from '@/app/api/v1/admin/users/route'
import { NextRequest } from 'next/server'

// Mock the getToken function
jest.mock('next-auth/jwt')
const mockGetToken = getToken as jest.MockedFunction<typeof getToken>

describe('/api/v1/admin/users', () => {
  beforeEach(() => {
    // Reset mocks
    mockGetToken.mockReset()
  })

  describe('POST /api/v1/admin/users', () => {
    it('should require admin authentication', async () => {
      // Mock no token (unauthenticated)
      mockGetToken.mockResolvedValue(null)

      const request = new NextRequest('http://localhost:3000/api/v1/admin/users', {
        method: 'POST',
        body: JSON.stringify({
          name: 'Test User',
          email: 'test@example.com',
          roleIds: ['role-1']
        })
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.success).toBe(false)
      expect(data.error).toBe('Authentication required')
    })

    it('should require admin role', async () => {
      // Mock token with non-admin role
      mockGetToken.mockResolvedValue({
        id: 'user-1',
        name: 'Test User',
        email: 'test@example.com',
        role: 'USER'
      } as any)

      const request = new NextRequest('http://localhost:3000/api/v1/admin/users', {
        method: 'POST',
        body: JSON.stringify({
          name: 'Test User',
          email: 'test@example.com',
          roleIds: ['role-1']
        })
      })

      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(403)
      expect(data.success).toBe(false)
      expect(data.error).toBe('Insufficient permissions')
    })

    it('should create user with admin token', async () => {
      // Mock admin token
      mockGetToken.mockResolvedValue({
        id: 'admin-1',
        name: 'Admin User',
        email: 'admin@example.com',
        role: 'ADMIN'
      } as any)

      // Test implementation here...
    })
  })
})
```

---

## Fix 4: Additional Security Enhancements

### Rate Limiting
Add rate limiting to prevent brute force attacks:

```typescript
// lib/rateLimit.ts
import { NextRequest } from 'next/server'

const requests = new Map()

export function rateLimit(ip: string, limit: number = 10, window: number = 60000) {
  const now = Date.now()
  const userRequests = requests.get(ip) || []
  
  // Remove old requests outside the window
  const recentRequests = userRequests.filter((time: number) => now - time < window)
  
  if (recentRequests.length >= limit) {
    return false
  }
  
  recentRequests.push(now)
  requests.set(ip, recentRequests)
  
  return true
}
```

### Input Sanitization
Add input validation and sanitization:

```typescript
import { z } from 'zod'
import DOMPurify from 'isomorphic-dompurify'

const sanitizeString = (input: string) => {
  return DOMPurify.sanitize(input.trim())
}

const createUserSchema = z.object({
  name: z.string().min(2).max(100).transform(sanitizeString),
  email: z.string().email().transform(sanitizeString),
  phone: z.string().optional().transform(val => val ? sanitizeString(val) : val),
  organization: z.string().optional().transform(val => val ? sanitizeString(val) : val),
  roleIds: z.array(z.string().uuid()),
  isActive: z.boolean().optional().default(true)
})
```

---

## Testing Instructions

1. **Test Authentication**: Try accessing admin endpoints without authentication - should return 401
2. **Test Authorization**: Try accessing with non-admin role - should return 403
3. **Test Password Generation**: Create a user and verify email is sent with secure credentials
4. **Test Jest Configuration**: Run `pnpm test` - all tests should pass without Prisma errors

## Deployment Checklist

- [ ] All environment variables configured
- [ ] SMTP credentials tested
- [ ] Database permissions for user creation
- [ ] NextAuth.js session configuration verified  
- [ ] Rate limiting implemented
- [ ] Input sanitization added
- [ ] All tests passing
- [ ] Security review completed

**Estimated Time**: 4-6 hours for complete implementation and testing.

---

**Priority**: Complete Fix 1 and Fix 2 immediately - these are critical security vulnerabilities that prevent safe deployment.